You are given an array of strings arr[], where each arr[i] consists of lowercase english alphabets. You need to find the number of balanced strings in arr[] which can be formed by concatinating one or more contiguous strings of arr[].
A balanced string contains the equal number of vowels and consonants. 

Examples:

Input: arr[] = ["aeio", "aa", "bc", "ot", "cdbd"]
Output: 4
Explanation: arr[0..4], arr[1..2], arr[1..3], arr[3..3] are the balanced substrings with equal consonants and vowels.
Input: arr[] = ["ab", "be"]
Output: 3
Explanation: arr[0..0], arr[0..1], arr[1..1] are the balanced substrings with equal consonants and vowels.
Input: arr[] = ["tz", "gfg", "ae"]
Output: 0
Explanation: There is no such balanced substring present in arr[] with equal consonants and vowels
-------------------------------------------------------------------------------------------------

class Solution {
public:
    int countBalanced(vector<string>& arr) {
        unordered_map<int, int> freq;
        int prefixSum = 0, ans = 0;
        freq[0] = 1; // base case for empty prefix
        for (const string& word : arr) {
            int diff = 0;
            for (char ch : word) {
                if (isVowel(ch)) diff++;
                else diff--;
            }
            prefixSum += diff;
            ans += freq[prefixSum];
            freq[prefixSum]++;
        }
        return ans;
    }
    bool isVowel(char ch) {
        return ch == 'a' || ch == 'e' ||  ch == 'i' || ch == 'o' || ch == 'u';
    }
};
